; gfx12 reading from 2@0xCFF8
MMIO@0xa1d0 = { 0x8000 } ; gfx1201.regGCMC_VM_FB_LOCATION_BASE
MMIO@0xa1d4 = { 0x83fb } ; gfx1201.regGCMC_VM_FB_LOCATION_TOP
MMIO@0xa44c = { 0x0 } ; gfx1201.regGCVM_CONTEXT2_PAGE_TABLE_START_ADDR_LO32
MMIO@0xa450 = { 0x0 } ; gfx1201.regGCVM_CONTEXT2_PAGE_TABLE_START_ADDR_HI32
MMIO@0xa4cc = { 0xffffffff } ; gfx1201.regGCVM_CONTEXT2_PAGE_TABLE_END_ADDR_LO32
MMIO@0xa4d0 = { 0xf } ; gfx1201.regGCVM_CONTEXT2_PAGE_TABLE_END_ADDR_HI32
MMIO@0xa218 = { 0x3fffc07 } ; gfx1201.regGCVM_CONTEXT2_CNTL
MMIO@0xa3cc = { 0xdaab5001 } ; gfx1201.regGCVM_CONTEXT2_PAGE_TABLE_BASE_ADDR_LO32
MMIO@0xa3d0 = { 0x3 } ; gfx1201.regGCVM_CONTEXT2_PAGE_TABLE_BASE_ADDR_HI32
MMIO@0xa01c = { 0x0 } ; gfx1201.regGCMC_VM_FB_OFFSET

; Set up so that 0x10000 (16KB) page at 0x0 is at 0x4c9803000. Try to read 16 bytes from
; address 0xCFF8 will read page at 0x4c980fff8 to 0x4c9810008. There is no page boundary
; between these two addresses. The page is from 0x4c9803000 to 0x4c9813000
;
; There was a bug in the VM code read the bytes as if there was a page boundary
; at 0x4c9810000 by assumming masking the page size from the physical address of the read
; was a way to get the page boundary. It's not because there is no guarantee a physical
; page's address will be in alignment with the page size. As a result, it split the read
; in the middle of the page to 8 bytes from 0x4c980fff8 and 8 bytes from 0x4c9810000.
;
; Instead there should just be a single 16 bytes read from 0x4c980fff8.
;
; This may only be verifiable by turning on verbose output and checking the number of reads.
; Unfortunately, the test does not fail even with the old buggy code.

VRAM@0x3daab5000 = {0180abda03000000}
VRAM@0x3daab8000 = {0170abda03000000}
; Fragment size 4 -> 16KB pages
VRAM@0x3daab7000 = {f10480c903000010}
VRAM@0x3c98004c0 = {713080c904000080}
VRAM@0x4c980fff8 = {000102030405060708090a0b0c0d0e0f}

; BASE=0x00000003daab5001, VA=0x000000000000, PBA==0x0003daab5000, V=1, S=0, C=0, U=0, A=0, FS=0, P=0
;    \-> PDE2@{0x3daab5000/0x0}=0x00000003daab8001, VA=0x000000000000, PBA==0x0003daab8000, V=1, S=0, C=0, U=0, A=0, FS=0, P=0
;       \-> PDE1@{0x3daab8000/0x0}=0x00000003daab7001, VA=0x000000000000, PBA==0x0003daab7000, V=1, S=0, C=0, U=0, A=0, FS=0, P=0
;          \-> PDE0@{0x3daab7000/0x0}=0x10000003c98004f1, VA=0x000000000000, PBA==0x0003c98004c0, V=1, S=0, C=0, U=0, A=0, FS=4, P=0
;             \-> PTE@{0x3c98004c0/0x0}=0x80000004c9803071, VA=0x000000000000, PBA==0x0004c9803000, V=1, S=0, C=0, Z=0, X=1, R=1, W=1, FS=0, SW=0, T=0, G=0, D=0, P=1, MTYPE=NC
;                \-> Computed address we will read from: vram:4c980fff8 (MCA:4c980fff8), (reading: 16 bytes from a 65536 byte page)
